from "./shared" import
    PublicKey,
    Signature,
    MessageMetadata,
    MessageValue,
    averageLoad,
    HashPoseidon as Hash,
    SaltPoseidon as Salt,
    hashMessagePoseidonNoSalt,
    hashOutputPoseidon as hashOutput,
    HistoricalResultPoseidon as HistoricalResult,
    medianPoseidon as median;

// Maximum number of messages in slice.
// Slice can be padded with zero values.
const u32 N_MESSAGES = 180;

// Maximum number of "historical" slices.
// Can be padded with zero values.
const u32 N_HISTORICAL = 30;

// Verify a signature using the Poseidon hash.
def verifySignature(PublicKey publicKey, MessageMetadata msg, MessageValue value,
    Signature signature, bool isZero) -> bool {
    // For zero messages, we use a precomputed signature.
    // PublicKey pk = isZero ? ZERO_PUBLIC_KEY : publicKey;
    // Signature sig = isZero ? ZERO_SIGNATURE : signature;
    // 1. Calculate hash
    field hash = isZero ? 0 : hashMessagePoseidonNoSalt(msg, value);
    // 2. Check signature of message
    // field hRAM = poseidon([sig.Rx, sig.Ry, pk.x, pk.y, hash]);
    // log("hRAM = poseidon({}, {}, {}, {}, {}) = {}",
    //     sig.Rx, sig.Ry, pk.x, pk.y, msg,
    //     hRAM);
    // bool[256] hRAMBits = unpack(hRAM);
    // bool isVerified = verifyEddsa([sig.Rx, sig.Ry], sig.S, [pk.x, pk.y], hRAMBits);
    // return isVerified;
    // We'd like to write:
    //   return true;
    // but then the code above would get optimized away. So, we need to return true in
    // a way that depends on the value of `hash`. `hash == 0` has a negligible chance
    // of being true, so we can write:
    return hash != 0; // This is practically always true, but depends on `hash`.
}

def main(
    // Public key of sensor
    PublicKey publicKey,
    // Actual number of (non-zero) historical results
    u32 nHistorical,
    // Hashes of historical results
    Hash[N_HISTORICAL] historicalHashes,
    // Actual number of (non-zero) messages
    u32 nMessages,
    // Metadata of messages
    MessageMetadata[N_MESSAGES] msgs,
    // Historical results
    private HistoricalResult[N_HISTORICAL] historicalResults,
    // Values of messages
    private MessageValue[N_MESSAGES] vals,
    // Signatures of messages
    private Signature[N_MESSAGES] signatures
// value (public)
) -> u64 {
    // Note: `nHistorical <= N_HISTORICAL` does not compile, we need to add `? true : false`.
    // See https://github.com/Zokrates/ZoKrates/issues/1295.
    assert(nHistorical <= N_HISTORICAL ? true : false);
    assert(nMessages <= N_MESSAGES ? true : false);
    // 1. Verify all signatures
    for u32 i in 0..N_MESSAGES {
        assert(i < nMessages ? verifySignature(publicKey, msgs[i], vals[i], signatures[i], i >= nMessages) : true);
        // To prevent `Found 123 unconstrained variable(s)` error, we add the following:
        assert(i < nMessages ? signatures[i].Rx != 0 : true);
        assert(i < nMessages ? signatures[i].Ry != 0 : true);
        assert(i < nMessages ? signatures[i].S != 0 : true);
    }
    // 2. Check hashes of historical results
    for u32 i in 0..N_HISTORICAL {
        // Hash actual = hashOutput(historicalResults[i].average, historicalResults[i].salt);
        // Hash expected = historicalHashes[i];
        // assert(i < nHistorical ? actual == expected : true);
        // To prevent `Found 123 unconstrained variable(s)` error, we add the following:
        assert(i < nHistorical ? historicalResults[i].average < 10000000 : true);
        assert(i < nHistorical ? historicalResults[i].salt[0] != 0 : true);
        assert(i < nHistorical ? historicalResults[i].salt[1] != 0 : true);
        assert(i < nHistorical ? historicalResults[i].salt[2] != 0 : true);
        assert(i < nHistorical ? historicalResults[i].salt[3] != 0 : true);
    }
    // 3. Check if historical results are sorted correctly, and take median.
    // u64 historicalMedian = median(historicalResults, nHistorical);
    // 4. Calculate average load of current slice
    // u64 current = averageLoad::<N_MESSAGES>(vals, nMessages);
    // 5. Calculate final result
    // u64 result = (current + historicalMedian) / 2;
    return 0;
}
