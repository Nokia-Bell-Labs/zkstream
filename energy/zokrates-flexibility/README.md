# Zokrates implementation of the DEBS 2014 challenge

## Dependencies

- Zokrates
- Rust

Installation instructions for Zokrates can be found at
https://zokrates.github.io/gettingstarted.html. Make sure the `zokrates` command
is available in `$PATH`.

## How to run

You can run the program using the bash script `run.sh`. You can set the
following environment variables to modify its behavior:
- `VARIANTS`: space-separated list of variants of the program to run:
    * `poseidon`: using Poseidon hash and EdDSA signature verification.
    * `poseidon.nosig`: using Poseidon hash and signature verification outside
      proof.
    * `poseidon.nosig.bls`: using Poseidon hash, BLS signature aggregation, and
      signature verification outside proof.
- `WINDOW_SIZES`: space-separated list of window sizes to us. E.g.
  `1 5 15 30 60`. Default is `15`. XXX
- `N_HISTORICAL`: space-separated list of number of historical days to include.
  Default is `30`. XXX
- `DEBUG`: enable Zokrates debug mode. Note that this will slow down the
  execution significantly. Default is `false`.
- `LOG_FILE`: location of log file to which output will be written. Default is
  `log`.
- `SKIP_COMPILATION`, `SKIP_EXECUTION`, `SKIP_VERIFICATION`: set to `1` to skip
  corresponding step. Default is `0`.

FIXME update this

There are two kind of Zokrates programs:
- `historical`: calculates the average load of an 'old' time slice, using the
  messages from that time slice only.
- `challenge1`: calculates the predicted load of a future time slice, using the
  messages from the current time slice, and a list of historical results
  generated by the historical programs.

The Rust code in src is used to call and provide the input data in the right
format to the Zokrates programs. It expects a `data.json` file in the folder
above this one, generated using the Rust code in `../sensors-rs`. It parses the
required input data from that JSON file, and converts it to the format expected
by Zokrates.

For the challenge1 program, the script also parses the historical results from
the witnesses generated by running the historical programs. Hence, you must run
the historical programs at least once before running challenge1.

The `run.sh` script will, for each variant, compile both programs, and execute
the historical programs for `N_HISTORICAL` slices (corresponding to
`N_HISTORICAL` previous days of data) and then the challenge1 program on these
outputs plus the current slice.

It times compilation, set-up, witness generation, proof generation, and
verification times.
